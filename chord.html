<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Type Chart</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            padding-top: 50px;
        }

        text {
            font-family: sans-serif;
            font-size: 20px;
        }

        line {
            stroke: #888888;
            stroke-width: 2;
        }

        circle {
            fill: #444;
            cursor: pointer;
        }
    </style>
</head>

<body>
    <svg id="chart">
        <defs>
            <marker id="arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#888" />
            </marker>
            <marker id="red-arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#f00" />
            </marker>
            <marker id="blue-arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#00f" />
            </marker>
            <marker id="purple-arrow" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto">
                <polygon points="0 0, 10 3.5, 0 7" fill="#80f" />
            </marker>
        </defs>
    </svg>
    <script>
        const labels = [
            "Fire",
            "Earth",
            "Lightning",
            "Toxic",
            "Water",
            "Undead",
            "Light",
            "Air",
            "Dark"
        ];
        // Each connection is defined as [source, target]
        const connections = [
            [0, 7],
            [4, 0],
            [6, 8],
            [8, 6],
            [4, 1],
            [2, 1],
            [3, 7],
            [2, 4],
            [5, 1],
            [6, 5],
            [8, 0],
            [8, 2]
        ];
        // Initialize counters
        const counts = labels.map(() => ({ incoming: 0, outgoing: 0 }));
        // Count incoming and outgoing lines
        connections.forEach(([source, target]) => {
            counts[source].outgoing += 1;
            counts[target].incoming += 1;
        });
        // Output the counts
        labels.forEach((label, i) => {
            console.log(`${label}: Incoming = ${counts[i].incoming}, Outgoing = ${counts[i].outgoing}`);
        });
        const svg = document.getElementById("chart");
        svg.setAttribute("width", window.innerWidth * 0.9);
        svg.setAttribute("height", window.innerHeight * 0.9);
        const centerX = svg.getAttribute('width') / 2;
        const centerY = svg.getAttribute('height') / 2;
        let radius = Math.min(centerX, centerY) * 0.9 / 2;
        const pointCoords = [];
        // Create a lookup for lines later
        const drawnLines = [];
        // Place points around the circle
        labels.forEach((label, i) => {
            const angle = (2 * Math.PI / labels.length) * i - Math.PI / 2;
            const x = centerX + radius * Math.cos(angle);
            const y = centerY + radius * Math.sin(angle);
            pointCoords.push({ x, y });
            // Create label text
            const labelEl = document.createElementNS("http://www.w3.org/2000/svg", "text");
            const labelOffset = 1
            labelEl.setAttribute("x", x);
            labelEl.setAttribute("y", y);
            if (x > window.innerWidth / 2) {
                labelEl.setAttribute("dx", `${labelOffset}em`);
            } else if (x < window.innerWidth / 2) {
                labelEl.setAttribute("dx", `-${labelOffset}em`);
            }
            if (y > window.innerHeight / 2) {
                labelEl.setAttribute("dy", `${labelOffset}em`);
            } else if (y < window.innerHeight / 2) {
                labelEl.setAttribute("dy", `-${labelOffset}em`);
            }
            // Adjust text-anchor based on x position relative to center
            if (Math.abs(x - centerX) < 10) {
                labelEl.setAttribute("text-anchor", "middle");
            } else {
                labelEl.setAttribute("text-anchor", x < centerX ? "end" : "start");
            }
            // Create tspan elements for the label details
            function tspanFormat(text = '', weight = 'normal', style = 'normal') {
                const item = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
                item.textContent = text;
                item.setAttribute("font-weight", weight);
                item.setAttribute("font-style", style);
                item.setAttribute("data-point", i); // store the index
                labelEl.appendChild(item);
            }
            const connectList = [];
            connections.forEach(connection => {
                if (connection[0] === i && !connectList.includes(connection[1])) {
                    connectList.push(connection[1]);
                } else if (connection[1] === i && !connectList.includes(connection[0])) {
                    connectList.push(connection[0]);
                }
            });
            const count = connectList.length;
            const incoming = connections.filter(([_, target]) => target === i).length;
            const outgoing = connections.filter(([source]) => source === i).length;
            const tspanData = [
                [label, "bold", 'normal'],
                [` | ${outgoing - incoming}`, "normal", 'italic']
            ];
            tspanData.forEach(item => {
                tspanFormat(item[0], item[1], item[2]);
            });
            labelEl.style.fontSize = '3em';
            svg.appendChild(labelEl);
            // Create a circle at the point and add a click listener
            const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            circle.setAttribute("cx", x);
            circle.setAttribute("cy", y);
            circle.setAttribute("r", 8);
            circle.setAttribute("data-point", i); // store the index
            circle.addEventListener("click", onPointClick);
            svg.appendChild(circle);
        });
        // Draw lines between connected points with data attributes for source and target
        connections.forEach(([a, b]) => {
            const { x: x1, y: y1 } = pointCoords[a];
            const { x: x2, y: y2 } = pointCoords[b];
            const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
            line.setAttribute("x1", x1);
            line.setAttribute("y1", y1);
            line.setAttribute("x2", x2);
            line.setAttribute("y2", y2);
            line.setAttribute("marker-end", "url(#arrow)");
            // Store the connection direction on the line
            line.dataset.source = a;
            line.dataset.target = b;
            svg.appendChild(line);
            drawnLines.push(line);
        });
        // Click handler for a point
        function onPointClick(e) {
            // Reset all lines to the default color
            drawnLines.forEach(line => {
                line.style.stroke = "#888888"
                line.setAttribute("marker-end", "url(#arrow)");
            });
            // Remove italics from all labels
            document.querySelectorAll("text tspan").forEach(tspan => {
                tspan.setAttribute("font-style", "normal");
                tspan.setAttribute('font-size','1em')
            });
            const clickedIndex = Number(this.getAttribute("data-point"));
            // Italicize the clicked label
            document.querySelectorAll(`text tspan[data-point="${clickedIndex}"]`).forEach(tspan => {
                tspan.setAttribute("font-style", "italic");
                tspan.setAttribute('font-size','1.5em')
            });
            // Highlight relevant lines
            drawnLines.forEach(line => {
                const source = Number(line.dataset.source);
                const target = Number(line.dataset.target);
                if (source !== clickedIndex && target !== clickedIndex) return;
                const reverseExists = drawnLines.some(l => {
                    return Number(l.dataset.source) === target && Number(l.dataset.target) === source;
                });
                if (reverseExists) {
                    line.style.stroke = "#80f";
                    line.setAttribute("marker-end", "url(#purple-arrow)");
                } else {
                    if (source === clickedIndex) {
                        line.style.stroke = "#00f";
                        line.setAttribute("marker-end", "url(#blue-arrow)");
                    } else if (target === clickedIndex) {
                        line.style.stroke = "#f00";
                        line.setAttribute("marker-end", "url(#red-arrow)");
                    }
                }
            });
        }
    </script>
</body>

</html>